## page was renamed from ObpLovelyPython/WebModules
##language:zh
##OBP项目图书reST通用文章模板

||status|| 草稿 ||HuangYi; 60%||

[[TableOfContents]]

##startInc
= 深入探索Python的Web开发 =
那么小白决定进一步探索 python web开发更高级一点的技术了，行者建议他从基础入手。

当用户在浏览器中输入网址，浏览器便找到web服务器，向它发起http请求，
web服务器再找到web应用程序执行之，并把结果返回给客户端浏览器。

这么说做web开发首先要有web服务器才行，一说到web服务器大家可能会联想到
apache、lighttpd 等成熟稳定高效的web服务器，
但是在开发阶段最好有一个简单方便的开发服务器，容易重启容易调试。
等开发调试完毕，再将代码部署到成熟稳定高效的web服务器。
而使用python做web开发，最后部署的阶段是非常轻松的，在本章的后面便会提到。

== 开发服务器 ==

那么 python2.5 就自带了一个叫做 wsgiref 模块，它提供一些专业 web 开发所需要的一些基础工具，比如一个开发服务器：

{{{#!python
# -*- coding: utf-8 -*-
from wsgiref import simple_server

# 定义一个输出 hello world 和环境变量的简单web应用程序
def hello_app(environ, start_response):
    # 输出 http 头，text/plain 表示是纯文本
    start_response('200 OK', [('Content-type','text/plain')])
    # 准备输出的内容
    content = []
    content.append('Hello world')
    for key, value in environ.items():
        content.append('%s : %s' % (key, value))
    # 输出，根据 wsgi 协议，返回的需要是一个迭代器，返回一个 list 就可以
    return ['\n'.join(content)]

# 构造开发服务器对象，设置绑定的地址和端口，并把 hello world 应用程序传给他
server = simple_server.make_server('localhost', 8080, hello_app)
# 启动开发服务器
server.serve_forever()
}}}

把以上代码以utf-8编码保存成python程序，不妨命名为 main.py，
然后执行上面这个程序后，打开浏览器，随便访问一个以 http://localhost:8080 
开头的网址即可看到 environ 所包含的内容。

继续前进之前先补充一点基础支持，浏览器和web应用之间使用的是 http 协议，它规定了
请求和响应的格式。

请求主要包括请求的方法、请求的URL、请求头、请求体。请求的方法
http 规定的有 GET、POST、PUT、DELETE，只不过通过浏览器发起的web请求一般只涉及
GET 和 POST 请求，GET 请求顾名思义，一般用来从服务器获取内容，而POST往往用来修改内容，
一般通过提交 html 的 form 表单发起 POST 请求。
而从协议上来看 GET、POST 请求最大的区别就是 GET 请求没有请求体，而 POST 请求有，
这意味这 POST 请求可以通过请求体向web服务器传送大量的数据，甚至是上传文件，当然 GET 请求
也可以通过 URL 本身以及其参数向web服务器传递信息，比如 url?arg1=value1&arg2=value2 。

请求头就是一些描述请求包本身的一些描述信息了，比如编码、包长度等。

http 的响应的格式更简单一些，就是包括状态码、响应头和响应体，
状态码表示该请求的结果，比如 200 表示成功；404表示资源没有找到；500表示服务器错误；
301表示该资源已经换了地址，客户端需要跳转等。
响应头和请求类似，就是一些响应包的描述数据，
响应体就是 POST 请求时，form表单中填写的内容了。

web服务器接收到原始的 http 请求后进行一定程度的包装再交给 web 应用程序，web应用程序再
以一定的协议返回数据给 web服务器，web服务器然后就将数据包装成 http 响应包再发给浏览器。
那么就完成了一个请求的整个生命周期。

其实 cgi 就是web服务器与web应用程序之间的一个协议，web服务器将请求信息放到环境变量里面，
web应用程序再通过标准输出输出它的响应头和相应内容。

那么 wsgiref 带的这个开发服务器与我们的应用程序之间所使用的协议叫做 wsgi，
wsgi 协议的详细内容可以参考：http://www.python.org/dev/peps/pep-0333/ ，
在这里你只需要知道，wsgi 和 cgi 类似，同样是将http请求包装成一种key-value对，
只不过cgi通过环境变量，wsgi直接使用python的字典对象，直接通过参数完成传递。

比如上面 hello_app 函数接收的第一个参数 environ 就是包含web请求信息的字典，
上面这个web程序输出的就是这个字典的全部内容，里面有比如请求的路径（PATH_INFO），
，请求的方法（REQUEST_METHOD），客户端cookie（HTTP_COOKIE），客户端的IP（REMOTE_ADDR）等等信息。

hello_app 的第二个参数 start_response 是一个函数，web 应用在输出响应内容前需要先调用它
来输出状态码和响应头。

动态的web应用程序是要和用户进行交互的，意味着我们需要得到用户的输入，然后作出相应地
动作。比如通过 environ['QUERY_STRING'] 就可以获得用户 GET 请求传递的参数，不过
还是一个原始的字符串的形式，比如：'key1=value1&key2=value2'，还需要我们自己解析其格式，
当然通过 python 字符串方便的 split 方法，解析这样一个字符串还是很方便的。但是遇到 POST
请求就没那么方便了，尤其是遇到文件上传的请求，那就更复杂了。

这些东西这里就不深入介绍了。小白很快就发现 python 世界有一些专门的模块
可以用来处理 environ 信息，把它变成更加方便操纵的格式。

== 处理web请求和响应 ==

小白发现也又有几个模块可以用来处理 web 请求和响应，webob 就是其中之一。

安装 webob 之前我们需要先安装 setuptools ，一个包管理的工具，该工具可以自动为我们搜索并下载想要的
软件包。 在这个页面 http://pypi.python.org/pypi/setuptools 下面，非windows平台可以下载 .egg 文件
，然后修改权限直接执行之，或者下载源码包，解压后执行 python setup.py install ，
windows平台的用户也可以直接下载 exe 后缀名的可执行安装程序，下载后直接运行就好了。

安装完 setuptools 后，安装 webob 就很简单了，打开一个命令行窗口，执行 easy_install webob ，
setuptools 能够自动找到最新的版本并自动下载安装。当然，如果嫌它单线程的下载速度有点慢，你也
可以直接到 http://pypi.python.org/pypi 搜到相应的包，手动下载，
然后加压并执行 python setup.py install ，后面的包的安装方法和这里类似。

安装完成后我们可以直接在 python shell 里对 webob 所提供的功能进行试验:

{{{#!python
>>> # 导入 Request 对象
>>> from webob import Request
>>> environ = {}
>>> # 使用 Request 来包装 environ 字典
>>> req = Request(environ)
}}}

基本使用方法就是这样了，使用一个 Request 类来包装 environ ，然后通过 Request 对象的属性和方法，
对 environ 进行访问。由于只有在 web 环境下才能得到一个真实的 environ 字典，为了方便大家在
python shell 里面对其进行试验，webob 还提供一种方法可以模拟一个简易的web请求，请看：

{{{#!python
>>> from webob import Request
>>> # 构建一个简易的 web 请求
>>> req = Request.blank('http://localhost:8080/hello?name=python')
>>> from pprint import pprint
>>> # 查看该 web 请求具体内容
>>> pprint(req.environ)
{'HTTP_HOST': 'localhost:8080',
 'PATH_INFO': '/hello',
 'QUERY_STRING': 'name=python',
 'REQUEST_METHOD': 'GET',
 'SCRIPT_NAME': '',
 'SERVER_NAME': 'localhost',
 'SERVER_PORT': '8080',
 'SERVER_PROTOCOL': 'HTTP/1.0',
 'webob._parsed_query_vars': (MultiDict([('name', 'python')]), 'name=python'),
 'wsgi.errors': <open file '<stderr>', mode 'w' at 0x00B6F0B0>,
 'wsgi.input': <cStringIO.StringI object at 0x00B6A2F0>,
 'wsgi.multiprocess': False,
 'wsgi.multithread': False,
 'wsgi.run_once': False,
 'wsgi.url_scheme': 'http',
 'wsgi.version': (1, 0),
 'wsgiorg.routing_args': ((), {})}
>>> # 通过 Request 的属性可以更方便地对其进行访问
>>> req.method
'GET'
>>> req.host
'localhost:8080'
>>> req.path
'/hello'
>>> req.query_string
'name=python'
>>> # 可以用字典的方式访问 GET 参数
>>> req.GET['name']
'python'
>>> # 访问 POST 数据也类似，不过显然，这不是一个 POST 请求
>>> req.POST
<NoVars: Not a form request>
>>> # 不过我们也可以模拟一个 POST 请求
>>> req.method = 'POST'
>>> # 手动设置模拟 POST 的请求数据
>>> req.body = 'name=python'
>>> # 这下就可以了
>>> req.POST['name']
'python'
>>> # 还可以很方便获取 cookie 数据
>>> # 先模拟一段带来的cookie的客户端请求
>>> req.headers['Cookie'] = 'name=python'
>>> # 同样，通过字典的方式对 cookie 进行访问
>>> req.cookies
{'name': 'python'}
}}}

同样，web应用程序的响应数据，比如状态码，响应头，设置 cookie 等，
可以通过 webob 提供的 Response 对象来进行包装：

{{{#!python
>>> from webob import Response
>>> # 构造一个 Response对象
>>> res = Response(status=200, body='hello world')
>>> # 设置响应头
>>> res.headers['content-type'] = 'text/plain'
>>> # 设置 cookie
>>> res.set_cookie('name', 'python', max_age=360, path='/',
...                domain='example.org', secure=True)
>>> # 构建原始的 http 响应包
>>> print res
200 OK
Content-Length: 11
content-type: text/plain
Set-Cookie: name=python; Domain=example.org; expires="Thu, 25-Sep-2008 14:28:07
GMT"; Max-Age=360; Path=/; secure

hello world
}}}

试完了基本功能，就试试把它加入我们的 web 应用程序吧。
通过 webob 对请求和响应进行包装，我们可以让处理业务逻辑的代码接受
Request对象，返回 Response 对象，这样我们可以简化 hello_app 本身的代码，
让它更加专注于业务逻辑：

{{{#!python
# -*- coding: utf-8 -*-
from wsgiref import simple_server
from webob import Request, Response

# 我们顺便增加了一个功能，就是根据用户在 URL 后面传递的参数
# 显示相应的内容
def hello_app(request):
    content = []
    # 获取 get 请求的参数
    content.append('Hello %s'%request.GET['name'])
    # 输出所有 environ 变量
    for key, value in request.environ.items():
        content.append('%s : %s' % (key, value))

    response = Response(body='\n'.join(content))
    response.headers['content-type'] = 'text/plain'
    return response

# 对请求和响应进行包装
def wrapper(environ, start_response):
    request = Request(environ)
    response = hello_app(request)
    # response 对象本身也实现了与 wsgi 服务器之间通讯的协议，
    # 所以可以帮我们处理与web服务器之间的交互。
    return response(environ, start_response)

server = simple_server.make_server('localhost', 8080, wrapper)
server.serve_forever()
}}}

这样，执行这个程序后，当我们访问地址 http://localhost:8080/hello?name=python 时，
就可以看到 hello python 和后面跟的一串 wsgi 的环境变量了。

== 模板 ==

不过显然，现实生活转那个的 web程序很少直接返回这么简单的纯文本信息，虽然
ajax 的时代，返回 json、xml 这样的特定格式数据的web程序也越来越多。
但毕竟，很多时候还是需要返回一个 html 页面的，而把一个复杂的 html 页面
代码直接写到python代码里面就太丑陋了，有没有办法可以把它和业务代码分离开来，
再通过某种方式向其中填充内容呢？

模板就是对这个问题的答案。

python里面的模板引擎主要有mako、genshi、jinja等。mako 主要特点在于模板里面
可以比较方便的嵌入python代码，而且执行效率一流；genshi 的特点在于基于 xml，
非常简单易懂的模板语法，对于热爱xhtml的朋友来说是很好的选择，同时也可以嵌入python
代码，实现一些复杂的展现逻辑；jinja 和 genshi 一样拥有很简单的模板语法，只是不
依赖于 xml 的格式，同样很适合设计人员直接进行模板的制作，同时也可以嵌入python
代码实现一些复杂的展现逻辑。

小白看 mako 挺顺眼的，于是就钻研了它一把。
可以到这里 http://www.makotemplates.org/download.html 找到最新版本的下载地址，下载解压，
然后执行 python setup.py install 就可以了。 

下面的代码就是写的一个简单的 mako 模板文件，里面直接输出一个 name 对象，
并使用 python 的 for 循环来把传递给它的 data 字典的内容填充到一个html列表
（mako模板的详细语法请参考：http://www.makotemplates.org/docs/syntax.html）。

{{{
<html>
  <head>
    <title>简单mako模板</title>
  </head>
  <body>
    <h5>Hello ${name}!</h5>
    <ul>
      % for key, value in data.items():
      <li>
        ${key} - ${value}
      <li>
      % endfor
    </ul>
  </body>
</html>
}}}

然后要做的就是给模板传递name和data两个对象，渲染模板，然后输出最终的 html 代码了，
可以编写如下三句代码实现：

{{{#!python
# -*- coding: utf-8 -*-
# 导入模板对象
from mako import Template
# 使用模板文件名构造模板对象
tmpl = Template('./simple.html')
# 构造一个简单的字典填充模板，并print出来
print tmpl.render(name='python', data = {'a':1, 'b':2})
}}}

执行以上程序，就可以看到通过模板输出的 html 代码了。
功能研究清楚了，小白开始试着把它整合到这个web应用中来，
这个时候小白发现，需要改动的部分主要集中在 hello_app 这个函数了，
因为业务逻辑都集中在这里进行了，在加入模板的同时，小白决定进行一次小小的重构，
把 hello_app 给彻底独立出来，形成单独的模块 controller.py ：

{{{#!python
# -*- coding: utf-8 -*-
from webob import Response
from mako import Template

def hello_app(request):
    tmpl = Template('./simple.html.html')
    content = tmpl.render(name=request.GET['name'], data=request.environ)
    return Response(body=content)
}}}

这样 main.py 就变成这样了：

{{{#!python
# -*- coding: utf-8 -*-
from wsgiref import simple_server
from webob import Request
from controller import hello_app

def wrapper(environ, start_response):
    request = Request(environ)
    response = hello_app(request)
    return response(environ, start_response)

server = simple_server.make_server('localhost', 8080, wrapper)
server.serve_forever()
}}}

执行 python main.py ，并访问 http://localhost:8080/hello?name=python 你就可以看到通过模板输出的页面了。

现在两个文件，逻辑清晰了很多，以后对业务逻辑的修改就只需要修改 controller.py 了，
main.py 相对就比较固定了。

现在两个文件加起来是 15 行代码，比最开始那个程序增加了 5 行 ;-)

== ORM ==

作为一个动态网站，有很多数据需要持久存储，关系数据库在这方面通常都是不二选择。

有了 webob 愉快的经历，小白遇到问题都习惯性地要了解一下有没有现成的工具可以使用，
当小白向行者问道如何才能简化对关系数据库的操作时，行者郑重向小白推荐了 sqlalchemy 这个库。

sqlalchemy 是一个 ORM （对象-关系映射）库，提供python对象与关系数据库之间的映射，
也就是程序只需要对 python 对象进行操作，sqlalchemy 自动把这些操作映射为
关系数据库的操作，并执行之。
可以直接使用python代码描述数据库结构，然后 sqlalchemy 自动创建之，
可以直接创建一个 python 对象设置好属性，或者修改一条属性，
sqlalchemy 就自动执行插入或者更新操作，
还可以直接调用 python 对象方法进行查询，通过参数进行过滤等等。

sqlalchemy 还可以自动映射 python 对象的继承，可以实现eager loading、lazy loading，
可以直接将 Model 映射到自定义的 SQL 语句，等等等等。可以说 sqlalchemy 既有不输于
Hibernate 的强大功能，同时不失 Python 的简洁优雅。

在这里 http://www.sqlalchemy.org/download.html 找到最新版本的下载地址，下载解压，
然后执行 python setup.py install 进行安装。

代码胜千言，sqlalchemy 到底可以做什么，直接上代码展示下 sqlalchemy 的基本功能吧：

{{{#!python
# -*- coding: utf-8 -*-
from sqlalchemy.ext.declarative import declarative_base

# 创建数据库引擎，这里我们直接使用 python2.5 自带的数据库引擎：sqlite，
# 直接在当前目录下建立名为 data.db 的数据库
engine = create_engine('sqlite:///data.db')
# sqlalchemy 中所有数据库操作都要由某个session来进行管理
# 关于 session 的详细信息请参考：http://www.sqlalchemy.org/docs/05/session.html
Session = scoped_session(sessionmaker(autocommit=False, autoflush=False, bind=engine))
Base = declarative_base()

class Dictionay(Base):
    # python 对象对应关系数据库的表名
    __tablename__ = 't_dictionay'
    # 定义自动，参数含义分别为：数据库字段名，字段类型，其他选项
    key = Column('key', String(255), primary_key=True)
    value =  Column('value', String(255))

# 创建数据库
Base.metadata.create_all(engine)

session = Session()
for item in ['python','ruby','java']:
    # 构造一个对象
    dictionay = Dictionay(key=item, value=item.upper())
    # 告诉 sqlalchemy ，将该对象加到数据库
    session.add(dictionay)

# 提交session，在这里才真正执行数据库的操作，添加三条记录到数据库
session.commit()

# 查询数据库中Dictionary对象对应的数据
for dictionay in session.query(Dictionary):
    print dictionay.name, dictionay.value
}}}

直接执行这个程序就可以了，最后输出的就是数据库中的数据了。
不过这只是个单独的 demo，为了方便对 sqlalchemy 进行试验，也方便最好整合到 web 应用里面去，
还需要先对它的代码结构进行一下重构。

首先提取出一个公用的 model.py 文件。

{{{#!python
# -*- coding: utf-8 -*-
from sqlalchemy.ext.declarative import declarative_base

engine = create_engine('sqlite:///data.db')
Session = scoped_session(sessionmaker(autocommit=False, autoflush=False, bind=engine))
Base = declarative_base()

class Dictionay(Base):
    __tablename__ = 't_dictionay'
    key = Column('key', String(255), primary_key=True)
    value =  Column('value', String(255))
}}}

因为创建数据库以及初始化测试数据的工作只需要做一次就可以了，我们把这个部分代码放到一个
单独的程序里面去。

{{{#!python
# -*- coding: utf-8 -*-
# 导入公用的 model 模块
from model import Base, Session, Dictionary

# 创建数据库
Base.metadata.create_all(engine)

# 插入初始数据
session = Session()
for item in ['python','ruby','java']:
    dictionay = Dictionay(key=item, value=item.upper())
    session.add(dictionay)

session.commit()
}}}

现在打开 python shell ，导入 models 模块，对照 sqlalchemy 的文档（http://www.sqlalchemy.org/docs/），就可以试验 sqlalchemy 的各种功能了，这里就不再赘述。

然后再将这个功能也整合进我们的 web 程序里面来吧，修改 controller.py 文件：

{{{#!python
# -*- coding: utf-8 -*-
from webob import Response
from mako import Template
# 导入公用的 model 模块
from model import Session, Dictionary

def hello_app(request):
    session = Session()
    # 查询到所有 Dictionary 对象
    dictionaries = session.Query(Dictionary)
    # 然后根据 Dictionary 对象的 name、value 属性把列表转换成一个字典
    data = dict([(dictionary.name, dictionary.value) for dictionary in dictionaries])

    tmpl = Template('./simple.html.html')
    content = tmpl.render(name=request.GET['name'], data=data)
    return Response(body=content)
}}}

执行 python main.py ，并访问 http://localhost:8080/hello?name=python，就可以看到从数据库中
取出来的三条测试数据了。

终于像模像样了，现在回过头来看一下，究竟整出来一个什么样的程序呢？小白不禁惊呼：“这不是...不就是...传说中的...框架？！”

##endInc
= TODO =
TODO 其他组件的介绍

TODO 部署

