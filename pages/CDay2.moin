##language:zh
#pragma section-numbers on



[[TableOfContents]]

= CDay 2 界面!不应该是难事儿 =
## 一句话本章精要精神
`网站软件化绝对不是空话!`

== 清点需求 ==

小白开始自豪的清点在到现在已经自主实现的功能:
 1. 扫描光盘内容并存储为硬盘上的文本文件
  * 存储成*.cdc 的文本文件 `cdctools.cdWalker()`
  * 可以快速指定保存目录 `PyCDC.do_dir()`
  * 可以快速指定保存的文件名 `PyCDC.do_walk()`
 1. 根据储存到硬盘上的光盘信息计件进行搜索
  * 可以搜索指定目录中所有*.cdc文件  `cdctools.cdcGrep()`
  * 可以指定关键字进行搜索 `PyCDC.do_find()`
   * 列出所有含有关键字的信息行

== GUI有必要嘛?冇必要嘛? ==
"能不能给个界面哪？每次都要输入命令，很麻烦的说..."

呜乎矣哉，果然！果然有这种主流反馈汹涌而来了!

小白一边腹诽，一边也在憧憬:"不习惯使用命令行的都是初级用户！咳，但是俺也喜欢图形界面哪……但是好难的！"

不用去列表询问，小白也知道Python 无所不能，一搜索也知道至少有:
 1. Tk
 1. wxPython
 1. Qt
3大GUI 框架可以快速组织桌面软件界面出来，但是！

就算是写出来，也没无法简单的发布成友好的坚固的稳定的傻瓜化的安装程序哪...

列表中一问才知道,虽然有N多发布打包框架,但是都至少得包含完整的Python 虚拟机环境,这一项就是5Mb,想来核心代码不超过200行的东西,发布成过Mb大小的东西,小白就感觉脸红...这不白玩Python 了?一点也不 Cool!

乍办咧...?
 
倒个苦水先...

=== 浏览器也是GUI ===
'''一句话惊醒梦里人!'''

现在不都流行网站软件化嘛? HTML+浏览器,可不就是用户最熟悉,而且最有宽容心理准备的界面嘛?!

好哪!就整个本地站点式的界面出来就好,要求用户先安装好Python 环境,然后,也不用安装,解开压缩包,运行一条命令,就可以通过浏览器看到一个本地功能网站来使用 `PyCDC` 就好!

== Web应用框架 ==
'''有时候选择太多,也是种痛苦...'''

再次呜乎矣哉! 小白这刚刚一动念头就搜索到这种页面:
 * [http://wiki.python.org/moin/WebFrameworks WebFrameworks]
 * [http://wiki.woodpecker.org.cn/moin/PyWebFrameList Python WEB应用框架纵览]
密密麻麻一大片应用框架...

还有人站着说话不腰痛的分析"[http://xlp223.yculblog.com/post.1634226.html 为何有如此多的python web 框架?]"
 * E文出处:[http://bitworking.org/news/Why_so_many_Python_web_frameworks Why so many Python web frameworks?]
 * 不过看在人家用60行代码就完成了个 web 框架,小白实在是无话可说了 -- "这Python 不服不成哪!"

"俺不想整个复杂的强大的有DB支持等等高级特性的网站,就是想用Python 快速完成一个有限功能的本地网站哪!" -- 小白在列表中吼到

很快,行者给出了回应...

== Karrigell ==
'''最简单和省心的Web 应用框架,就是Karrigell 了...实在是最听话的一种了...'''

好吧，那就尝试使用Karrigell 来整个桌面网站型的界面！


=== 介绍 ===
'''http://karrigell.sourceforge.net/''' 主站 的介绍也是非常的精妙

Karrigell 为了大家不同的习惯居然提供了多达5种WEB 应用发布形式:

 1. 自然Python脚本{{{#!python
#hallo.py
print "<h1>Squares</h1>"
for i in range(10):
    print "%s :<b>%s</b>" %(i,i*i)
 }}} -- 有大量的HTML 要亲自组织和输出？不爽直！
 1. HTML 嵌 Python脚本{{{
#hallo.hip
"<h1>Squares</h1>"
for i in range(10):
    "%s :<b>%s</b>" %(i,i*i)
 }}} -- 同样得亲自组织HTML输出？不爽直！
 1. Python 嵌 HTML脚本{{{
#hallo.pih
<h1>Squares</h1>
<%
for i in range(10):
    print "%s :<b>%s</b>" %(i,i*i)
%> }}} -- 这不就是PHP嘛?没劲!
 1. CGI脚本{{{
#hallo.py
print 'Content-type: text/html'
print
print "<h1>Squares</h1>"
for i in range(10):
    print "%s :<b>%s</b>" %(i,i*i)
 }}} -- 比自然Python 还要麻烦,而且对发布目录有约束?不爽直！
 1. Karrigell 服务{{{#!python
#hallo.ks
def index():
    print "<h1>Squares</h1>"
    for i in range(10):
        print "%s :<b>%s</b>" %(i,i*i)
 }}}-- 看起来好象支持函式化的组合? 就这种了!


 文档:: '''http://karrigell.sourceforge.net/en/front.htm''' 有进一步的细节介绍
 
 不过小白已经有足够的信心立即使用Karrigell 来启动自个儿的应该了

=== 运行 ===
首先得将环境运行起来,然后可以边修改,边在页面中看到结果的话,就非常爽直了!

也不用问,看着简单的文档,一般就3板斧:
 1. 下载,安装:
  * 晕!Karrigell 居然不用特别安装,解开压缩包,在任何地方都可以运行!
  * 使用不包含demo 文档的核心版本`'Karrigell-core-2.3.5.tgz'`,解压缩了才800多K!
 1. 配置:
  * 仅仅修订一行:{{{
#path/to/Karrigell-2.3.5/Karrigell.ini
...
[Server]
port=8081
...
  }}}想将网站启动到 `:8081` 端口,避开用户可能的己有默认`:80`网站
 1. 运行{{{
python Karrigell.py 
 }}} 完事儿! 网站已经启动,界面已经拥有!

attachment:070830_k-0-run_857X108_scrot.png

=== 组织 ===
前后看了看,发觉,默认的,Karrigell 发布 `Karrigell-2.3.5/webapps` 目录为网站根

为了独立组织各种已有代码,在 其中创建 `cdc` 子目录,
先再将原先 `index.html` 复制一份到 `cdc` 中
然后修订默认首页`index.html` 追加一链接{{{
<h1><a href="cdc/">PyCDC Web</a><h1>
}}}

刷个新: attachment:070830_k-0-idx_517X224_scrot.png 
嗬嗬嗬,老实的显示出来,而且可以正常点击!

然后就是想法儿,将 `cdc/index.html` 重构为 `cdc/index.ks` 并可以调用原先的 `cdctools.py` 中准备好的函式,完成同样的在命令行环境中可以干的活就得!

=== 重构 ===
先来个20行:{{{#!python
# -*- coding: utf-8 -*-
def _htmhead(title):
    '''默认页面头声明
    @note: 为了复用，特别的组织成独立函式,根据Karrigell 非页面访问约定，函式名称前加"_"
    @param title: 页面标题信息
    @return: 标准的HTML代码
    '''
    htm = """<html><HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>%s</title></HEAD>
<body>"""%title
    return htm
## 默认页面尾声明
htmfoot="""
<h5>design by:<a href="mailto:Zoom.Quiet@gmail.com">Zoom.Quiet</a>
    powered by : <a href="http://python.org">Python</a> +
 <a href="http://karrigell.sourceforge.net"> KARRIGELL 2.3.5</a>
</h5>
</body></html>"""

def index(**args):
    print _htmhead("PyCDC WEB")
    print htmfoot
}}}

刷个新: attachment:070830_k-0_512X97_scrot.png

真乘...小白参考网络中搜索出来的前辈的实例,一试即成! 感觉真是不一般的爽快!

而且有两个小的技巧到手:
 1. 在Karrigell 中,函式名称有前缀"_" 的话,就会当作秘密函式,不认为是可访问的页面,凡是辅助性函式都可以这么来
 1. 直接使用 Python 的函式规范将 `index()` 的参数声明成动态参数`**args` 这样一来将所有功能集成到首页中,进行点击提交等等操作时, `index()` 函式就可以智能的接受不定长度,形式,格式的参数了!

==== 导入 ====
好了,将原先的 工具脚本导入进来就可以通过网页调用原先的功能了,但是...

怎么从 `PyDays/pyd+2/Karrigell-2.3.5/webapps/cdc/index.ks` 可以`import` 到 `PyDays/pyd+2/cdctools.py`???

好象,貌似, `import` 操作不象网页的包含动作有相对路径可以玩的?

嗯嗯嗯,先不管了,复制过来一个, `import` ! 怎么看是导入成功了?{{{
from cdctools import *
print dir()    #通过检查名称空间进行测试
}}}
attachment:070830_k-1-cdctools_494X259_scrot.png

咔咔咔,瞧见了熟悉的几个函式名称,DONE!

 PS:: 小白万分感动的看到Karrigell 提供了友好,丰富,明晰的网页调试信息汇报
 attachment:070830_k-2-debug_866X538_scrot.png


==== 表单 ====
好了,组织好了,接下来就是表单组织,最后连接上即有功能就得!

 HTMLTags:: '''http://karrigell.sourceforge.net/en/htmltags.htm''' 有说,Karrigell 提供一个非常OOP的支持模块可以快速的函式样儿的组织生成HTML代码:
 {{{print HTML( HEAD(TITLE('Test document')) +
        BODY(H1('This is a test document')+
             TEXT('First line')+BR()+
             TEXT('Second line')))

将生成:

    <HTML>
    <HEAD>
    <TITLE>Test document</TITLE>
    </HEAD>
    <BODY>
    <H1>This is a test document</H1>
    First line
    <BR>
    Second line
    </BODY>
    </HTML>
}}}但是,可以进行交互提交的表单,好象,貌似,无法函式化的生成哪...

有点郁,小白不想自个儿折腾,根据 `-1 day` 的经验:

`你能够碰到的问题,99%的情况下其它人已经遇到过了,所以,最佳的解决方式就是找到那段别人解决相似问题的代码!`

还是吼一声:"Karrigell 有表单快速生成模块嘛...."

果然有行者反馈:'''[http://wiki.woodpecker.org.cn/moin/KwDay3 Karrigell_QuickForm]'''

靠!!连名字都一样 `快速表单`!{{{#!python
def index(**args):
    '''默认主
    @note: 使用简单的表单／链接操作来完成原有功能的界面化
    @param args: 数组化的不定参数
    @return: 标准的HTML页面
    '''
    print _htmhead("PyCDC WEB")
    p = KQF('fm_cdwalk','POST',"index","CD Walk")
    p.addHtmNode('text',"keywd","文件名",{'size':20,'maxlength':50})
    p.addGroup(["submit","btn_submit","Walk it!","btn"])
    p.display()
    p = KQF('fm_cdwalk','POST',"index","CD Walk")
    p.addHtmNode('text',"keywd","关键字",{'size':20,'maxlength':50})
    p.addGroup(["submit","btn_submit","Search It!","btn"])
    p.display()
}}}得了您哪! 追加8行,完成两个功能针对性的表单

attachment:070830_k-form_473X320_scrot.png

==== 功能 ====
随便输入,提交,没有任何问题,但是怎么获得提交的信息?

http://karrigell.sourceforge.net/en/programming.htm -- 有说:
 * 嗯嗯嗯! 瞧着这 `QUERY` 内置变量就是亲切哪
追加:
{{{
    if 0 == len(QUERY):
        pass
    else:
        print QUERY
    print htmfoot
}}}再提交两次,彻底明白了网页参数的传送,绑定原先的功能!

{{{
## 全局变量
CDCPATH = "/path/to/LovelyPython/PyDays/pyd+2/cdc"
CDROM = '/media/cdrom0'
...
    if 0 == len(QUERY):
        pass
    else:
        if "Search" in QUERY['btn_submit']:
            print I("try search *.cdc for KEY:%s"%QUERY['keywd']),BR(),cdcGrep("%s/"%CDCPATH,QUERY['keywd'])
        elif "Walk" in QUERY['btn_submit']:
            iniCDinfo(CDROM,"%s/%s"%(CDCPATH,QUERY['keywd']))
        else:
            pass
    print htmfoot
}}}追加6行,完成核心功能绑定!

运行一下:
attachment:070830_k-search_483X435_scrot.png

成咧!! 嗬嗬嗬,一切太自然了...


==== 二传 ====
不过...这搜索匹配结果的输出也忒糙了点儿,随手改进一下吧:
{{{#!pythondef 
cdcGrep(cdcpath,keyword):
    filelist = os.listdir(cdcpath)          # 搜索目录中的文件
    for cdc in filelist:                    # 循环文件列表
        if ".cdc" in cdc:
            cdcfile = open(cdcpath+cdc)         # 拼合文件路径，并打开文件
            for line in cdcfile.readlines():    # 读取文件每一行，并循环
                if keyword in line:             # 判定是否有关键词在行中
                    print "<br/>",line                  # 打印输出
}}}唉呀呀? 好象没有反应?

{{{#!pythondef 
cdcGrep(cdcpath,keyword):
    export = ""
    filelist = os.listdir(cdcpath)          # 搜索目录中的文件
    for cdc in filelist:                    # 循环文件列表
        if ".cdc" in cdc:
            cdcfile = open(cdcpath+cdc)         # 拼合文件路径，并打开文件
            export += cdc
            for line in cdcfile.readlines():    # 读取文件每一行，并循环
                if keyword in line:             # 判定是否有关键词在行中
                    #print line                  # 打印输出
                    export += line
    print export
}}}呜乎矣哉...依然没有反应,页面居然输出是 `None`?!

...嗯嗯嗯...嗯嗯嗯?! 怎么意思? import 的函式不算Karrigell 体系里的,无法直接返回数据的?!

那么... `二传`一个!

小白没空深入研究Karrigell 和外部模块的交互原理,自然的决定使用第三方文件来进行数据传递...

因为,想用一超级 cool 的模块 `pickle` -- 序列化! 对象腌制器！ -- 据说可以将Python 的数据对象输出成文本文件，而且导入时直接转化成自然的对象！！！

{{{#!python
def cdcGrep(cdcpath,keyword):
    expDict = {}
    filelist = os.listdir(cdcpath)          # 搜索目录中的文件
    for cdc in filelist:                    # 循环文件列表
        if ".cdc" in cdc:
            cdcfile = open(cdcpath+cdc)         # 拼合文件路径，并打开文件
            expDict[cdc]=[]
            for line in cdcfile.readlines():    # 读取文件每一行，并循环
                if keyword in line:             # 判定是否有关键词在行中
                    #print line                  # 打印输出
                    expDict[cdc].append(line)
    pickle.dump(expDict,open("searched.dump","w"))

if __name__ == '__main__':      # this way the module can be
    '''cdctools 自测响应处理
    '''
    CDROM = '/media/cdrom0'
    CDCPATH = "/path/to/LovelyPython/PyDays/pyd+2/cdc/"
    cdcGrep(CDCPATH,"EVA")
    print pickle.load(open("searched.dump"))
}}}

attachment:070830_k-pickle_789X63_scrot.png

对应的导出文件`searched.dump`:{{{
(dp0
S'z.MCollection.29.cdc'
p1
(lp2
sS'mfj-00.cdc'
p3
(lp4
sS'MCollec.39.cdc'
p5
(lp6
sS'z.Animation.00.cdc'
p7
(lp8
S'[L:\\mAnimi\\Gainax\\EVAalbumESP]\r\n'
p9
asS'z.MFC.pop.02.cdc'
p10
(lp11
s.
}}}
果真可以从纯文本直接变成字典对象哪………… Cool!

{{{#完善首页代码为:...
def index(**args):
    ...
    if 0 == len(QUERY):
        pass
    else:
        if "Search" in QUERY['btn_submit']:
            if "" == QUERY['keywd']:
                print H3("pls import SearchKey!")
            else:
                print I("try search *.cdc for KEY:%s"%QUERY['keywd'])
                print BR()#,cdcGrep("%s/"%CDCPATH,QUERY['keywd'])
                cdcGrep("%s/"%CDCPATH,QUERY['keywd'])
                searcheDict = pickle.load(open("searched.dump"))
                for cdc in searcheDict.keys():
                    print H5(cdc)
                    for line in searcheDict[cdc]:
                        print BR(line)
        elif "Walk" in QUERY['btn_submit']:
            print I("try walk CD for:%s ..."%QUERY['keywd'])
            iniCDinfo(CDROM,"%s/%s"%(CDCPATH,QUERY['keywd']))
            print BR(),B("had export info. file as::%s/%s"%(CDCPATH,QUERY['keywd']))
        else:
            pass
    print htmfoot
}}}

 搜索时:: attachment:070830_k-search-good_422X546_scrot.png

 记录时:: attachment:070830_k-walk_579X367_scrot.png


=== TODO ===
Karrigell 这么听话，几乎是随想随写就完成了 Web 化的界面实现，接下来?

 美化!:: 嗬嗬嗬,这在HTML 中比在GUI 的各种框架代码中可以要超级 Easy 了! CSS 而已...
 

== web.py ==
'''web.py 则是绝对简单直接的应用框架,但是同样拥有各种高级特性!'''

原先就两个文件的完整最精简框架,现在虽然也发展到有十来个文件,但是也包含了从DB到模板到web服务林林总总所有高级web 应用的特性.

不过坚持了最Pythonic 的直接表述原则,小白看到的完整功能网站实例就8行:
{{{#!python
import web
urls = ('/(.*)', 'hello')
class hello:        
    def GET(self, name):
        i = web.input(times=1)
        if not name: name = 'world'
        for c in xrange(int(i.times)): print 'Hello,', name+'!'
if __name__ == "__main__": 
    web.run(urls, globals())
}}}

直接调用:`python tryweb.py`

attachment:070823_web.py_850X115_scrot.png

就会在本地 8080 端口发布一个可以响应用户URL 输入的网站来!

不过,实在太简单,什么都要自个儿来,不如 Karrigell 作的舒服呢... ;)


== 小结 ==
## 总体语法等等叙述,注意给出相关知识的阅读指导

== 练习 ==
## 设计实用练习,确保体例代码可以自由扩展出各种实用应用!
1. 如果在Karrigell 实例中，不复制 cdctools.py 到webapp 目录中，也可以令 index.ks 引用到？



----
::-- ZoomQuiet [[[DateTime(2007-04-13T16:29:37Z)]]]
[[PageComment2]]

